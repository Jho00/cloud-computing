# Практическая работа: CI/CD-конвейер для приложения

### Цель работы

В работе по Docker было разработано приложение, которое запускается в Docker. В этой работе его необходимо доработать и настроить ему ci/cd-конвейер

Список доработок, которые необходимо провести для приложения:
- Написать unit и/или интеграционные тесты для приложения 
- Настроить линтер для приложения 

### Требования:

При открытом pull-request/merge-request запускает ci/cd-pipeline

В этом пайплайне существуют следующие шаги (stages):
1. Проверяет, что приложение собирается (build). 
2. Запускает линтер (lint). 
3. Запускает тесты и рассчитывает coverage (test+coverage). 
4. Собирает Docker-образ (docker build).
5. (В новом или в том же pipeline). Выполняет push образа в Docker Hub при успешности предыдущих шагов.

**Входные данные и ограничения:**
Репозиторий с приложением из предыдущей работы.

В репозитории должны быть:
- Подробная и аккуратно-оформленная инструкция по запуску
- Конфиг линтера (например, flake8/ruff/eslint)
- Тесты (pytest/jest и т.п.) и генерация coverage
- Dockerfile для сборки образа.

Нельзя «рисовать» успех: pipeline должен реально падать, если:
- Сборка не проходит,
- Линтер находит ошибки (согласованный уровень),
- Тесты не проходят
- coverage ниже порога. Порог: 50%

**Ожидаемые результаты на выходе**
- Pipeline включает как минимум 4 job: build, lint, test, docker_build
- Coverage: Должна быть публикация отчёта (artifact) и/или парсинг процента из вывода. Ниже порога — pipeline падает.
- Docker: Собирается образ с тегом, зависящим от коммита/ветки (например, :$CI_COMMIT_SHORT_SHA).
- Выполняется push в Docker Hub: либо в отдельном job docker_push, либо как часть job, но лучше отдельно.
- Секреты: Логин/пароль (или токен) не хардкодить. Использовать переменные CI.