### 0. собираем проект в jar:
Cправа в idea нажать maven - package
После файл jar должен появиться в папке проекта, в директории target.

### 1. создаем в корне приложения (где название проекта) Dockerfile:
```
FROM maven:3.6.3-openjdk-17
COPY ./ ./
RUN mvn clean package -Dmaven.test.skip=true
CMD ["java", "-jar", "target/Library-0.0.1-SNAPSHOT.jar"]
```

```#RUN``` - собираю проект внутри докера

```#FROM``` - Oбраз создаётся на основе alpine linux с установленной openjdk11

```#ARG JAR_FILE=...``` - Переменной JAR_FILE присваивается путь к jar- архиву

```#WORKDIR``` - Назначаем рабочую директорию, в которой будут выполняться дальнейшие команды (перемещаемся в папку app)

```#COPY``` - Наш jar-файл, указанный в JAR_FILE, копируется в папку app, и копии задаётся имя app.jar

```#ENTRYPOINT``` - jar-файл запускается, собирается команда java -jar app.jar из заданной рабочей директории


### 2. создаем в корне docker-compose.yml

**ВАЖНО!!**
1) должна быть - ```POSTGRES_DB=library``` в db, иначе ошибка и спринг app не найдет базу. По названию сервиса docker compose
2) ```SPRING_DATASOURCE_URL=jdbc:postgresql://db(*):5432/library``` - вместо localhost (как в application.property) указываем ИМЯ КОНТЕЙНЕРА БАЗЫ = db (*)

либо в application.property ее сразу прописать, вместо SPRING_DATASOURCE_URL, но выезжала ошибка

### 3. Запускаем 
```docker-compose up``` - Cоздаются все контейнеры из файла

чтобы все удалить и запустить заново:
* ```docker-compose down``` - удаляет контейнеры
* ```docker rmi titleImage``` - удаляет образ
* ```docker-compose up``` - заново создает контейнеры

если ошибка
```[ERROR]   LibraryApplicationTests.contextLoads » IllegalState Failed to load ApplicationContext for [WebMergedContextConfiguration@13047d3d testClass:```
Или, если вы хотите игнорировать тесты, вы можете просто запустить:
```mvn clean install -Dmaven.test.skip=true```

### 4. ДОП инфа:
создать сеть:
```
docker network create -d bridge my-bridge-network
046a642a243e800acbe874c30a3e56a35019c96118b2b8bb3fc1e267fc0eb028
```
   
посмотреть все сети:
```docker network ls```

удалив driver:bridge из файла docker-compose.yml:
Здесь вы показали множество ручных настроек, которые Docker выполняет автоматически. Если у вас нет networks:объявления, Compose создает сеть с именем default и присоединяет к ней все контейнеры. Затем Docker автоматически назначает IP-адреса контейнерам и предоставляет систему DNS, которая может сопоставлять имена контейнеров с этими IP-адресами.

Это означает, что вам практически никогда не придется беспокоиться о внутренних IP-адресах контейнера. Они недоступны из-за пределов Docker (за исключением одной очень специфичной настройки хоста Docker), а внутри Docker вы можете использовать имена служб Compose в качестве имен хостов. Например, вы можете установить переменную среды PGHOST=db в app контейнере, и она будет преобразована в контейнер базы данных.

В своем вопросе и другом ответе вы намекаете на проблемы с ручным указанием сети driver:. В режиме, отличном от Swarm, bridge драйвер должен быть режимом по умолчанию, и вам не нужно указывать это явно.

https://docs.docker.com/engine/reference/commandline/network_create/
https://docs.docker.com/compose/networking/

### 5. создаю файлы .env - там же, где dockerfile, docker-compose.yml - один уровень
создаю для постгреса и приложения: postgres.env и app.env
после их добавляю в docker-compose:

```
env_file:
 - postgres.env
```

https://docs.docker.com/compose/environment-variables/set-environment-variables/

### 6. создаю файл nginx.conf и добавляю в docker compose


* Директива proxy_pass указывает NGINX куда отправлять запросы от клиентов. Все, что нужно сделать NGINX, это преобразовать имя хоста в адрес IPv4 или IPv6
* proxy_set_header Host — еще одна важная команда, которая в запросе к сайту донору выставляет правильное поле HOST. Без нее будет подставляться имя нашего прокси сервера и запрос будет ошибочным.

```include '6pm.conf'``` — логика модуля substitutions.

```proxy_cookie_domain``` — новая функция, которая появилась в nginx версии 1.1.15, без этой директивы приходилось делать так. Больше не нужно ломать голову, прописываете одну строчку и куки просто начинают работать.

```proxy_set_header Accept-Encoding "";``` — очень важная команда, которая заставляет сайт донор отдавать вам контент не в сжатом виде, иначе модуль substitutions не сможет выполнить замены.

```proxy_set_header Host``` — еще одна важная команда, которая в запросе к сайту донору выставляет правильное поле HOST. Без нее будет подставляться имя нашего прокси сервера и запрос будет ошибочным.
```proxy_pass``` — прямая адресация не работает в именованном локейшине, именно поэтому мы прописали адрес сайта донора в директиве upstream.
```proxy_redirect``` — многие сайты используют редиректы для своих нужд, каждый редирект нужно отловить и перехватить здесь, иначе запрос и клиент уйдет за пределы нашего уютного доменчика.

заменила ports на expose:
```EXPOSE``` — описание сетевых портов, которые будут прослушиваться в запущенном контейнере (подробнее);
Инструкция EXPOSEфактически не публикует порт. Он функционирует как своего рода документация между человеком, создающим образ, и человеком, запускающим контейнер, о том, какие порты предполагается публиковать.
https://docs.docker.com/engine/reference/builder/#expose


### ДОП ИНФА:

Это безопасно для: ```sudo pkill -u postgres```. Это убивает все процессы, запущенные от имени пользователя postgres . Или: ```pkill postgres```

в docker-compose nginx:
volumes - описываем именнованные тома
когда применяем конфигурацию, докер по умолчанию создает директиву:
```/var/lib/docker/volumes/```

networks - описываем сеть
brige - сеть по умолчанию

SERVICES:
image - имя с докер файла
container_name - имя контейнера
restart - определяет политику перезапуска контейнера, по умолчанию none.
unless-stop - чтобы не перезагружался без моего ведома
env_file - переменные окружения для контейнера
volums - именованные тома
networks - принадлоежность к сети
depend_on - зависит от: ждет запуска другого контейнера

ports - указываем порт, который хотим откртыть наружу.
в nginx 1) хост машины, 2) порт внутри контейнера


Автор: https://github.com/malinkovich

